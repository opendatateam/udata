describe('Markdown plugin', function() {
    const Vue = require('vue');

    Vue.use(require('plugins/markdown'));
    Vue.config.async = false;

    afterEach(function() {
        fixture.cleanup();
    });

    /**
     * Remove invisible nodes generated by Vue.js
     */
    function strip(el) {
        [...el.childNodes].forEach(function(node) {
            const is_comment = node.nodeType === Node.COMMENT_NODE;
            const is_empty_text = node.nodeType === Node.TEXT_NODE && !/\S/.test(node.nodeValue);
            if (is_comment || is_empty_text) {
                node.parentNode.removeChild(node);
            }
        });
        return el;
    }

    describe('markdown filter', function() {
        function el(text) {
            const vm = new Vue({
                el: fixture.set('<div>{{{text | markdown}}}</div>')[0],
                replace: false,
                data: {
                    text: text
                }
            });
            return strip(vm.$el);
        }

        it('should render empty string as ""', function() {
            expect(el('').childNodes).to.be.emtpy;
        });

        it('should render null value as ""', function() {
            expect(el(null).childNodes).to.be.empty;
        });
        it('should render undefined value as ""', function() {
            expect(el(undefined).childNodes).to.be.empty;
        });

        it('should markdown content', function() {
            expect(el('**aaa**')).to.have.html('<p><strong>aaa</strong></p>');
        });
    });

    describe('markdown directive', function() {
        function el(text) {
            const vm = new Vue({
                el: fixture.set('<div v-markdown="text"></div>')[0],
                data: {
                    'text': text
                }
            });
            return strip(vm.$el);
        }

        it('should render empty string as ""', function() {
            expect(el('').childNodes).to.be.emtpy;
        });

        it('should render null value as ""', function() {
            expect(el(null).childNodes).to.be.empty;
        });
        it('should render undefined value as ""', function() {
            expect(el(undefined).childNodes).to.be.empty;
        });

        it('should markdown content', function() {
            expect(el('**aaa**')).to.have.html('<p><strong>aaa</strong></p>');
        });
    });
});

describe('Markdown backend compliance', function() {
    const markdown = require('helpers/markdown').default;

    /**
    * An expect wrapper rendering the markdown
    * and then allowing to perform chai-dom expectation on it
    */
    function md(source) {
        const div = document.createElement('div');
        div.innerHTML = markdown(source);
        return div;
    }

    it('should transform urls to anchors', function() {
        const source = 'http://example.net/';
        expect(md(source)).to.have.html('<p><a href="http://example.net/">http://example.net/</a></p>');
    });

    it('should handles autolink', function() {
        const source = '<http://example.net/>';
        expect(md(source)).to.have.html('<p><a href="http://example.net/">http://example.net/</a></p>');
    });

    it('should not transform emails to anchors', function() {
        const source = 'coucou@cmoi.fr';
        expect(md(source)).to.have.html('<p>coucou@cmoi.fr</p>');
    });

    it('should not transform links within pre', function() {
        const source = '<pre>http://example.net/</pre>';
        expect(md(source)).to.have.html('<pre>http://example.net/</pre>');
    });

    it('should sanitize evil code', function() {
        const source = 'an <script>evil()</script>';
        expect(md(source)).to.have.html('<p>an &lt;script&gt;evil()&lt;/script&gt;</p>');
    });

    it('should handle soft breaks as <br/>', function() {
        const source = 'line 1\nline 2';
        expect(md(source)).to.have.html('<p>line 1<br>\nline 2</p>');
    });

    it('should properly render markdown tags not in allowed tags', function() {
        const source = '### titre';
        expect(md(source)).to.have.html('<h3>titre</h3>');
    });

    it('should render GFM tables (extension)', function() {
        const source = [
            '| first | second |',
            '|-------|--------|',
            '| value | value  |',
        ].join('\n');
        const expected = [
            '<table>',
            '<thead>',
            '<tr>',
            '<th>first</th>',
            '<th>second</th>',
            '</tr>',
            '</thead>',
            '<tbody>',
            '<tr>',
            '<td>value</td>',
            '<td>value</td>',
            '</tr>',
            '</tbody>',
            '</table>'
        ].join('\n');
        expect(md(source)).to.have.html(expected);
    });

    it('should render GFM strikethrough (extension)', function() {
        const source = 'Yay ~~Hi~~ Hello, world!';
        const expected = '<p>Yay <del>Hi</del> Hello, world!</p>';
        expect(md(source)).to.have.html(expected);
    });

    it('should handle GFM tagfilter extension', function() {
        // Test extracted from https://github.github.com/gfm/#disallowed-raw-html-extension-
        const source = [
            '<strong> <title>My Title</title></strong>',
            '<blockquote>',
            '  <xmp> is disallowed.</xmp>  <XMP> is also disallowed.</XMP>',
            '</blockquote>',
        ].join('\n')
        const expected = [
            '<p><strong> &lt;title&gt;My Title&lt;/title&gt;</strong></p>',
            '<blockquote>',
            '  &lt;xmp&gt; is disallowed.&lt;/xmp&gt;  &lt;XMP&gt; is also disallowed.&lt;/XMP&gt;',
            '</blockquote>',
        ].join('\n')
        expect(md(source)).to.have.html(expected)
    });

    it('should not filter legit markup', function() {
        const source = [
            '> This is a blockquote',
            '> with <script>evil()</script> inside',
        ].join('\n');
        const expected = [
            '<blockquote>',
            '<p>This is a blockquote<br>',
            'with &lt;script&gt;evil()&lt;/script&gt; inside</p>',
            '</blockquote>',
        ].join('\n');
        expect(md(source)).to.have.html(expected);
    });
});
